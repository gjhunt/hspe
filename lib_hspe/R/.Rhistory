dim(options_grid)
S
lapply(S,class)
lapply(S,function(x)class(x)=="nloptr")
lapply(S,function(x)class(x)=="nloptr"))
lapply(S,function(x)class(x)=="nloptr")
sapply(S,function(x)class(x)=="nloptr")
sapply(S,function(x)all(class(x)=="nloptr"))
sapply(S,function(x)all(class(x)=="nloptr")*1)
options_out
View(options_out)
head(options_out)
aggregate(result~algo,options_out,mean)
View(options_out)
sort(options_out$algo(
sort(options_out$algo)
order(options_out$algo)
options_out[order(options_out$algo),]
View(options_out[order(options_out$algo),])
View(options_out[order(options_out$algo),])
aggregate(result~algo,options_out,mean)
"NLOPT_LN_COBYLA"
options_grid$algo=="NLOPT_LN_COBYLA"
options_grid[options_grid$algo=="NLOPT_LN_COBYLA",]
ss
ss$g_ineq
ss$g_ineq & ss$g_ineq_deriv
!(ss$g_ineq & ss$g_ineq_deriv)
options_grid
options_grid
options_grid
options_grid
dim(options_grid)
View(options_grid)
options_grid
dim(options_grid)
View(options_grid)
View(options_grid[options_grid$g_ineq_deriv,])
View(options_grid[options_grid$g_eq_deriv,])
View(options_grid[options_grid$g_eq,])
?dtangle
View(options_grid[options_grid$g_eq,])
View(options_grid[options_grid$g_ineq,])
dim(options_grid)
S
View(options_out)
View(options_out[order(options_out$algo),])
head(options_grid)
options_grid
head(options_grid)
View(options_out)
View(options_out)
S[[291]]
NLOPT_LD_AUGLAG, NLOPT_LN_AUGLAG, NLOPT_LD_AUGLAG_EQ, NLOPT_LN_AUGLAG_EQ, NLOPT_GN_ISRES, NLOPT_LD_SLSQP
eq_algs
eq_algs
options_gird
options_grid
options_grid$algo
options_grid$g_eq
(options_grid$g_eq & options_grid$algo %in% eq_algs)
(options_grid$g_eq & !options_grid$algo %in% eq_algs)
View(options_grid[(options_grid$g_eq & !options_grid$algo %in% eq_algs),])
options_grid[(!options_grid$g_eq | options_grid$algo %in% eq_algs),]
dim(options_grid[(!options_grid$g_eq | options_grid$algo %in% eq_algs),])
dim(options_grid)
dim(options_grid)
dim(options_grid)
dim(options_grid)
options_out$algo=="NLOPT_LN_COBYLA"
options_out[options_out$algo=="NLOPT_LN_COBYLA",]
which(options_out$algo=="NLOPT_LN_COBYLA")
S[[195]]
S[[196]]
S[[197]]
S[[198]]
S[[199]]
S[[200]]
algo
mean_rate
mean_rate
mean_rate$algo
mean_rate$algo%in%eq_algs
mean_rate[!mean_rate$algo%in%eq_algs,]
mean_rate[!(mean_rate$algo%in%eq_algs),]

eq
eq_algs
mean_rate$mean
mean_rate$result
mean_rate$result==1
which(mean_rate$result==1)
mean_rate$algo[mean_rate$result==1]
which(options_out==mean_rate$algo[mean_rate$result==1])
which(options_out$algo%in%mean_rate$algo[mean_rate$result==1])
S[which(options_out$algo%in%mean_rate$algo[mean_rate$result==1])]
lapply(S[which(options_out$algo%in%mean_rate$algo[mean_rate$result==1])],"[","solution")
sapply(S[which(options_out$algo%in%mean_rate$algo[mean_rate$result==1])],"[","solution")
mean_rate
S
S[[1]]
S[[2]]
S[[10]]
S[[100]]
mean_rate
S
S[[1]]
options_out$result
options_out$result
mean_rate
mean_rate
View(options_out)
table(options_out$algo)
table(options_grid$algo)
view(options_out)
View(options_out)
grepl("BOBYQA",options_out$algo)
which(grepl("BOBYQA",options_out$algo))
S[which(grepl("BOBYQA",options_out$algo))]
options_out[S[which(grepl("BOBYQA",options_out$algo))],]
options_out[S[which(grepl("BOBYQA",options_out$algo))],]
options_out[which(grepl("BOBYQA",options_out$algo)),]
options_out[which(grepl("BOBYQA",options_out$algo))[3],]
which(grepl("BOBYQA",options_out$algo))
i=197
i=195
alg
algo
g_eq
g_ineq
algo
Kall
algo
options_out
options_out$g_ineq
options_out[options_out$g_ineq,]
dim(options_out[options_out$g_ineq,])
aggregate(result~algo,options_out[options_out$g_ineq,],mean)
grep("MMA|COBYLA|ORIG_DIRECT",algo_options)
grep("MMA|COBYLA|ORIG_DIRECT",algo_options,value=TRUE)
ineq_algs
dim(options_grid)
mean_rate
View(options_out)
mean_rate
S
View(mean_rate)
View(options_out)
i=113
out =         nloptr::nloptr(x0=p0,
                             eval_f = loss,
                             #eval_grad_f=f_deriv,
                             eval_g_ineq=g_ineq,
                             #eval_jac_g_ineq=g_ineq_deriv,
                             eval_g_eq=g_eq,
                             eval_jac_g_eq=g_eq_deriv,
                             lb=rep(0,Kall),ub=rep(1,Kall),
                             opts = list("algorithm"=algo,
                                         "xtol_rel"=tol,
                                         "maxeval"=maxiter,
                                         "print_level"=0))
out
out$solution
sum(out$solution)
i
i=114
i
i=115
i
i=116
i
View(options_out)
table(options_out$algo)
View(options_out)
i=49
View(options_out)
f_deriv
nlotpr.print.opts()
nloptr
nloptr.print.options()
maxiter
mean_rate
View(options_out)
i=113
View(options_out)
whic(options_out)
View(options_out)
i
i=49
View(options_out)
i=50
out
lapply(S,identity)
lapply(S,"[[","err")
sapply(S,"[[","err")
sapply(S,function(x)message(x$err))
sapply(S,function(x)toString(x$err))
grepl("gradient",sapply(S,function(x)toString(x$err)))
grepl("gradient",)
grepl("objective",sapply(S,function(x)toString(x$err)))
whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))]
whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))]
strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"_")
lapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"NLOPT")
)
strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"NLOPT")
strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"NLOPT*_")
strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"NLOPT")
strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm|but")
strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but")
lapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2")
)
)
lapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)
sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)
unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2))
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)))
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),collapse=",")
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),collapse=", ")
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),collapse=", ")
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),collapse=", ",sep="\"")
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),sep="\"")
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)))
paste(unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),collapse=",")
paste("\"",unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=",")
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=","))
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=",",sep=""))
whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))]
grepl("constraint",whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))])
whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))]
whaterr[grepl("constraint",sapply(S,function(x)toString(x$err)))]
whaterr[grepl("equality",sapply(S,function(x)toString(x$err)))]
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("equality",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=","))
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("equality",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=","))
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=",",sep=""))
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=",",sep=""))
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("equality",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=",",sep=""))
cat(paste("\"",unique(sapply(strsplit(whaterr[grepl("inequality",sapply(S,function(x)toString(x$err)))],"algorithm | but"),"[",2)),"\"",collapse=",",sep=""))
eq_algs
eq_grad_needed
eq_grad_needed
eq_grad_needed
options_grid
dim(options_grid)
View(options_out)
ineq_grad_needed
options_grid[77,]
eq_grad_needed
eq_grad_needed
options_grid[77,]
options_grid[77,]$algo
options_grid[77,]$algo%in%eq_grad_needed
eq_grad_needed
options_grid[77,]$algo==eq_grad_needed
sapply(S,function(x)toString(s$err))
sapply(S,function(x)toString(x$err))
sapply(S,function(x)toString(x$err))grad_needed
grad_needed
options_grid[77,]
whaterr[grepl("objective",sapply(S,function(x)toString(x$err)))]
whaterr[grepl("inequality",sapply(S,function(x)toString(x$err)))]
whaterr[grepl("equality",sapply(S,function(x)toString(x$err)))]
View(options_grid)
S[77]
lapply(S,function(x)toString(x$err)))
lapply(S,function(x)toString(x$err))
sapply(S,function(x)toString(x$err))
sapply(S,function(x)toString(x$err))[77]
grad_needed
View(options_out)
grad_needed
options_grid
View(options_grid)
options_grid[74,]
options_grid[74,]$algo %in% grad_needed
options_grid[74,]$algo %in% grad_needed & options_grid[74,]$f_deriv
dim(options_grid)
View(options_grid)
View(options_grid)
options_grid
options_grid
options_grid
dim(options_grid)
options_grid[74,]
View(options_out)
i=54
S[[i]]
i
i
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           eval_grad_f=f_deriv,
                           eval_g_ineq=g_ineq,
                           eval_jac_g_ineq=g_ineq_deriv,
                           eval_g_eq=g_eq,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
f_deriv
            nloptr::nloptr(x0=p0,
            nloptr::nloptr(x0=p0,


            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           eval_g_eq=g_eq,

                           lb=rep(0,Kall),ub=rep(1,Kall),

                           opts = list("algorithm"=algo,

                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           eval_g_eq=g_eq,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           eval_g_eq=g_eq,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           eval_g_eq=g_eq,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,

                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           eval_grad_f=f_deriv,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))


            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
            nloptr::nloptr(x0=p0,
                           eval_f = loss,
                           lb=rep(0,Kall),ub=rep(1,Kall),
                           opts = list("algorithm"=algo,
                                       "xtol_rel"=tol,
                                       "maxeval"=maxiter,
                                       "print_level"=0,
                                       "local_opts"=local_opts))
ESTIMATES
dim(ESTIMATES)
matplot(ESTIMATES)
View(options_out)
lapply(S,function(x)toString(x$err))
sapply(S,function(x)toString(x$err))
S
sapply(S,function(x)toString(x$solution))
sapply(S,function(x)toString(x$solution))
sapply(S,function(x)x$solution)
matplot(sapply(S,function(x)x$solution))
SOLNS
apply(SOLNS,2,sum)
options_out$result
options_out$result[22]
options_out$result[which(apply(SOLNS,2,sum)==1)]
options_out$result[]
which(apply(SOLNS,2,sum)==1)
View(options_out)
View(options_out[options_out$g_eq,])
S[options_out$g_eq]
SOLNS[,options_out$g_eq]
apply(SOLNS[,options_out$g_eq],2,sum)
SOLNS
options_grid
View(options_grid)
options_grid
opts
out
names(out)
out$solution
out$status
S
S
lapply(S,function(x)x$err)
lapply(S,"[[","err")
lapply(S,function(x)toString(x$err))
grepl("objective",lapply(S,function(x)toString(x$err)))
grepl("objective",the_errs)
the_errs[grepl("objective",the_errs)]
no_grad
what_err
whaterr
dim(options_grid)
dim(options_grid)
S
lapply(S,"[[","err")
mean_rate
SLNS
SOLNS
View(options_grid)
options_grid$g_eq
SOLNS[,options_grid$g_eq]
matplot(SOLNS)
fns
names(fns)
options_grid[,names(fns)[!sapply(fns,is.null)]]
apply(options_grid[,names(fns)[!sapply(fns,is.null)]],1,all)
apply(options_grid[,names(fns)[!sapply(fns,is.null)]],1,all)==TRUE
which(apply(options_grid[,names(fns)[!sapply(fns,is.null)]],1,all))
options_grid[,names(fns)[!sapply(fns,is.null)]]
colMeans(options_grid)
colMeans(options_grid[,-1])
saveRDS('options_grid.rds')
saveRDS('options_grid.rds',options_grid)
saveRDS(options_grid,'options_grid.rds')
opts
out
out
out
out
retv
out$opt_out
out$err
out$opt_out$par
out$err$par
optim_opts=list(pkg="DEoptimR")
optim_solve <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts=NULL, maxiter = 1000, tol = 1e-10, 
    p0 = NULL,verbose=TRUE) {

    Kall <- nrow(Z)
    if (is.null(p0)) 
        p0 <- rep(1/Kall, Kall)
    if (is.null(W)) 
        W <- rep(1, length(x))
    fs <- L(p0, x, Z, W)
  
    optimize <- switch(optim_opts$pkg,
                       "DEoptimR"=optim_solve_deoptimr(x=x, Z=Z, loss=loss, loss_deriv=loss_deriv, W = W, optim_opts=optim_opts, maxiter = maxiter, tol = tol,
                                                       p0 = p0,verbose=verbose),
                       "nloptr"=optim_solve_nloptr(x=x, Z=Z, loss=loss, loss_deriv=loss_deriv, W = W, optim_opts=optim_opts, maxiter = maxiter, tol = tol, 
    p0 = p0,verbose=verbose)
    )

    soln = switch(optim_opts,
                  "DEoptimR"=optimize$par,
                  "nloptr"=optimize$solution)
                  
    return(list(phat=soln,opt=optimize))
}

optim_solve_deoptimr <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts="DEOptimR",opts=NULL,maxiter = 1000, tol = 1e-10, p0 = NULL,verbose=TRUE){

    out = tryCatch({
        list(opt_out = DEoptimR::JDEoptim(lower = rep(0, nrow(Z)), upper = rep(1, nrow(Z)), 
                                          fn = loss, trace = TRUE, triter = maxiter/10, maxiter = maxiter, add_to_init_pop = cbind(diag(1, Kall), rep(1/Kall, Kall)), tol = tol, fnscale = fs),err=NULL)
    },error=function(e){
        list(opt_out=NULL,err=e)
    })
    out$solution = out$opt_out$par
    return(out)
}

optim_solve_nloptr <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts="DEOptimR",opts=NULL,maxiter = 1000, tol = 1e-10, p0 = NULL,verbose=TRUE){

    algo = optim_opts$algo
    opt_flags = optim_opts$fn_flags
    f_deriv = NULL
    g_ineq = NULL 
    g_ineq_deriv=NULL
    g_eq=NULL
    g_eq_deriv=NULL
    if("f_deriv"%in%opt_flags){
        f_deriv=loss_deriv
    }
    if("g_ineq"%in%opt_flags){
        g_ineq=constr
    }
    if("g_ineq_deriv"%in%opt_flags){
        g_ineq_deriv = constr_deriv
    }
    if("g_eq"%in%opt_flags){
        g_eq=constr
    }
    if("g_eq_deriv"%in%opt_flags){
        g_eq_deriv=constr_deriv
    }
    
    fns = list(f_deriv,g_ineq,g_ineq_deriv,g_eq,g_eq_deriv)
    names(fns)=c("f_deriv","g_ineq","g_ineq_deriv","g_eq","g_eq_deriv")
    names(fns)[!sapply(fns,is.null)]
    
    out = tryCatch({
        local_opts <- list("algorithm" = "NLOPT_LN_COBYLA",
                           "xtol_rel" = 1.0e-7 )
        list(opt_out = nloptr::nloptr(x0=p0,
                                      eval_f = loss,
                                      eval_grad_f=f_deriv,
                                      eval_g_ineq=g_ineq,
                                      eval_jac_g_ineq=g_ineq_deriv,
                                      eval_g_eq=g_eq,
                                      eval_jac_g_eq=g_eq_deriv,
                                      lb=rep(0,Kall),ub=rep(1,Kall),
                                      opts = list("algorithm"=algo,
                                                  "xtol_rel"=tol,
                                                  "maxeval"=maxiter,
                                                  "print_level"=0,
                                                  "local_opts"=local_opts)),
             err=NULL)
    },error=function(e){
        list(opt_out=NULL,err=e)
    })
    out$solution = out$opt_out$solution
    return(out)
}


P0
i
i=1
opt$solution
opt
opt
optim_solve <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts=NULL, maxiter = 1000, tol = 1e-10, 
    p0 = NULL,verbose=TRUE) {

    Kall <- nrow(Z)
    if (is.null(p0)) 
        p0 <- rep(1/Kall, Kall)
    if (is.null(W)) 
        W <- rep(1, length(x))
    fs <- L(p0, x, Z, W)
  
    optimize <- switch(optim_opts$pkg,
                       "DEoptimR"=optim_solve_deoptimr(x=x, Z=Z, loss=loss, loss_deriv=loss_deriv, W = W, optim_opts=optim_opts, maxiter = maxiter, tol = tol,
                                                       p0 = p0,verbose=verbose),
                       "nloptr"=optim_solve_nloptr(x=x, Z=Z, loss=loss, loss_deriv=loss_deriv, W = W, optim_opts=optim_opts, maxiter = maxiter, tol = tol, 
    p0 = p0,verbose=verbose)
    )
                  
    return(list(phat=optimize$solution,opt=optimize))
}
opt
opt$phat
sum(opt$phat)
optim_opts
optim_opts=list(pkg="nloptr")
optim_opts
opt
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_COBYLA")
opt
opt$phat
sum(opt$phat)
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_AUGLAG_EQ")
opt
opt$phat
sum(opt$phat)
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_AUGLAG_EQ",opt_flags=c("g_eq"))
opt
opt$phat
sum(opt$phat)
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_AUGLAG_EQ",opt_flags=c("g_eq"))
opt_flags
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_AUGLAG_EQ",fn_flags=c("g_eq"))
opt$phat
sum(opt$phat)
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_AUGLAG",fn_flags=c("g_ineq"))
opt$phat
sum(opt$phat)
opt$phat/sum(opt$phat)
optim_opts=list(pkg="nloptr",algo="NLOPT_LN_AUGLAG",fn_flags=c("g_ineq","f_deriv"))
opt$phat
options_grid
View(options_grid)
View(options_grid[,c(1,2,3,5))
View(options_grid[,c(1,2,3,5)])
devtools::load_all()
opt$phatdata_type = NULL, gamma = NULL, markers = NULL, marker_method = "ratio", summary_fn = mean, 
    optim_opts = list(pkg = "DEoptimR"), sto = TRUE, inv_scale = function(x) 2^x, 
    dtangle_init = FALSE, seed = NULL, verbose = FALSE) {
    
    stopifnot(all(n_markers > 0))
    stopifnot(!is.null(c(references, pure_samples)))
    
    cmbd <- combine_Y_refs(Y, references, pure_samples)
    Y <- cmbd$Y
    pure_samples <- cmbd$pure_samples
    
    prc <- process_markers(Y, pure_samples, n_markers, data_type, gamma, markers, 
        marker_method)
    n_markers <- prc$n_markers
    mrkrs <- prc$mrkrs
    gamma <- prc$gamma
    
    phats <- dtangle2_est_phats(Y = Y, pure_samples = pure_samples, markers = mrkrs, 
        gamma = gamma, optim_opts = optim_opts, sto = sto, inv_scale = inv_scale, 
        dtangle_init = dtangle_init, seed = seed, verbose = verbose)
    if (!is.null(references)) 
        phats <- phats[-unlist(pure_samples), , drop = FALSE]
    
    return(list(estimates = phats, markers = mrkrs, n_markers = n_markers, gamma = gamma))
}

dtangle2_est_phats <- function(Y, pure_samples = NULL, markers = NULL, gamma = NULL, 
    optim_opts = list(pkg = "DEoptimR"), sto = TRUE, inv_scale = function(x) 2^x, 
    dtangle_init = FALSE, seed = NULL, verbose = FALSE) {
    if (!is.null(seed)) 
        set.seed(seed)
    pure <- unlist(pure_samples)
    mrks <- unlist(markers)
    X <- inv_scale(Y[-pure, mrks, drop = FALSE])
    Z <- t(sapply(pure_samples, function(x) apply(Y[x, mrks, drop = FALSE], 2, mean)))
    Z <- inv_scale(Z)
    W <- rep(1, ncol(X))
    
    Kall <- nrow(Z)
    P0 <- array(1/Kall, c(nrow(X), Kall))
    if (dtangle_init) 
        P0 <- dtangle(Y = Y, pure_samples = pure_samples, markers = markers, gamma = gamma)$estimates
    
    i <- 1
    dt_opt <- function(x) {
        if (verbose) 
            cat("====> ", i, "\n")
        loss <- function(p) L(p, x, Z, W, sto = FALSE)
        loss_deriv <- function(p) L_deriv(p, x, Z, W, sto = FALSE)
        opt <- optim_solve(x, Z, loss, loss_deriv, W = W, optim_opts = optim_opts, 
            p0 = P0[i, ], verbose = verbose)
        i <<- i + 1
        return(opt)
    }
    
    opts <- apply(X, 1, dt_opt)
    phats_all <- t(sapply(opts, "[[", "phat"))
    colnames(phats_all) <- rownames(Z)
    
    if (sto) {
        phats_all <- phats_all/rowSums(phats_all)
    }
    
    return(phats_all)
}

optim_solve <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts = NULL, maxiter = 1000, 
    tol = 1e-10, p0 = NULL, verbose = TRUE) {
    
    Kall <- nrow(Z)
    if (is.null(p0)) 
        p0 <- rep(1/Kall, Kall)
    if (is.null(W)) 
        W <- rep(1, length(x))
    fs <- L(p0, x, Z, W)
    
    optimize <- switch(optim_opts$pkg, DEoptimR = optim_solve_deoptimr(x = x, Z = Z, 
        loss = loss, loss_deriv = loss_deriv, W = W, optim_opts = optim_opts, maxiter = maxiter, 
        tol = tol, p0 = p0, verbose = verbose), nloptr = optim_solve_nloptr(x = x, 
        Z = Z, loss = loss, loss_deriv = loss_deriv, W = W, optim_opts = optim_opts, 
        maxiter = maxiter, tol = tol, p0 = p0, verbose = verbose))
    
    return(list(phat = optimize$solution, opt = optimize))
}

optim_solve_deoptimr <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts = "DEOptimR", 
    opts = NULL, maxiter = 1000, tol = 1e-10, p0 = NULL, verbose = TRUE) {
    
    out <- tryCatch({
        list(opt_out = DEoptimR::JDEoptim(lower = rep(0, nrow(Z)), upper = rep(1, 
            nrow(Z)), fn = loss, trace = TRUE, triter = maxiter/10, maxiter = maxiter, 
            add_to_init_pop = cbind(diag(1, Kall), rep(1/Kall, Kall)), tol = tol, 
            fnscale = fs), err = NULL)
    }, error = function(e) {
        list(opt_out = NULL, err = e)
    })
    out$solution <- out$opt_out$par
    return(out)
}

optim_solve_nloptr <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts = "DEOptimR", 
    opts = NULL, maxiter = 1000, tol = 1e-10, p0 = NULL, verbose = TRUE) {
    
    algo <- optim_opts$algo
    opt_flags <- optim_opts$fn_flags
    f_deriv <- NULL
    g_ineq <- NULL
    g_ineq_deriv <- NULL
    g_eq <- NULL
    g_eq_deriv <- NULL
    if ("f_deriv" %in% opt_flags) {
        f_deriv <- loss_deriv
    }
    if ("g_ineq" %in% opt_flags) {
        g_ineq <- constr
    }
    if ("g_ineq_deriv" %in% opt_flags) {
        g_ineq_deriv <- constr_deriv
    }
    if ("g_eq" %in% opt_flags) {
        g_eq <- constr
    }
    if ("g_eq_deriv" %in% opt_flags) {
        g_eq_deriv <- constr_deriv
    }
    
    fns <- list(f_deriv, g_ineq, g_ineq_deriv, g_eq, g_eq_deriv)
    names(fns) <- c("f_deriv", "g_ineq", "g_ineq_deriv", "g_eq", "g_eq_deriv")
    names(fns)[!sapply(fns, is.null)]
    
    out <- tryCatch({
        local_opts <- list(algorithm = "NLOPT_LN_COBYLA", xtol_rel = 1e-07)
        list(opt_out = nloptr::nloptr(x0 = p0, eval_f = loss, eval_grad_f = f_deriv, 
            eval_g_ineq = g_ineq, eval_jac_g_ineq = g_ineq_deriv, eval_g_eq = g_eq, 
            eval_jac_g_eq = g_eq_deriv, lb = rep(0, Kall), ub = rep(1, Kall), opts = list(algorithm = algo, 
                xtol_rel = tol, maxeval = maxiter, print_level = 0, local_opts = local_opts)), 
            err = NULL)
    }, error = function(e) {
        list(opt_out = NULL, err = e)
    })
    out$solution <- out$opt_out$solution
    return(out)
}


opt$phatdata_type = NULL, gamma = NULL, markers = NULL, marker_method = "ratio", summary_fn = mean, 
    optim_opts = list(pkg = "DEoptimR"), sto = TRUE, inv_scale = function(x) 2^x, 
    dtangle_init = FALSE, seed = NULL, verbose = FALSE) {
    
    stopifnot(all(n_markers > 0))
    stopifnot(!is.null(c(references, pure_samples)))
    
    cmbd <- combine_Y_refs(Y, references, pure_samples)
    Y <- cmbd$Y
    pure_samples <- cmbd$pure_samples
    
    prc <- process_markers(Y, pure_samples, n_markers, data_type, gamma, markers, 
        marker_method)
    n_markers <- prc$n_markers
    mrkrs <- prc$mrkrs
    gamma <- prc$gamma
    
    phats <- dtangle2_est_phats(Y = Y, pure_samples = pure_samples, markers = mrkrs, 
        gamma = gamma, optim_opts = optim_opts, sto = sto, inv_scale = inv_scale, 
        dtangle_init = dtangle_init, seed = seed, verbose = verbose)
    if (!is.null(references)) 
        phats <- phats[-unlist(pure_samples), , drop = FALSE]
    
    return(list(estimates = phats, markers = mrkrs, n_markers = n_markers, gamma = gamma))
}

dtangle2_est_phats <- function(Y, pure_samples = NULL, markers = NULL, gamma = NULL, 
    optim_opts = list(pkg = "DEoptimR"), sto = TRUE, inv_scale = function(x) 2^x, 
    dtangle_init = FALSE, seed = NULL, verbose = FALSE) {
    if (!is.null(seed)) 
        set.seed(seed)
    pure <- unlist(pure_samples)
    mrks <- unlist(markers)
    X <- inv_scale(Y[-pure, mrks, drop = FALSE])
    Z <- t(sapply(pure_samples, function(x) apply(Y[x, mrks, drop = FALSE], 2, mean)))
    Z <- inv_scale(Z)
    W <- rep(1, ncol(X))
    
    Kall <- nrow(Z)
    P0 <- array(1/Kall, c(nrow(X), Kall))
    if (dtangle_init) 
        P0 <- dtangle(Y = Y, pure_samples = pure_samples, markers = markers, gamma = gamma)$estimates
    
    i <- 1
    dt_opt <- function(x) {
        if (verbose) 
            cat("====> ", i, "\n")
        loss <- function(p) L(p, x, Z, W, sto = FALSE)
        loss_deriv <- function(p) L_deriv(p, x, Z, W, sto = FALSE)
        opt <- optim_solve(x, Z, loss, loss_deriv, W = W, optim_opts = optim_opts, 
            p0 = P0[i, ], verbose = verbose)
        i <<- i + 1
        return(opt)
    }
    
    opts <- apply(X, 1, dt_opt)
    phats_all <- t(sapply(opts, "[[", "phat"))
    colnames(phats_all) <- rownames(Z)
    
    if (sto) {
        phats_all <- phats_all/rowSums(phats_all)
    }
    
    return(phats_all)
}

optim_solve <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts = NULL, maxiter = 1000, 
    tol = 1e-10, p0 = NULL, verbose = TRUE) {
    
    Kall <- nrow(Z)
    if (is.null(p0)) 
        p0 <- rep(1/Kall, Kall)
    if (is.null(W)) 
        W <- rep(1, length(x))
    fs <- L(p0, x, Z, W)
    
    optimize <- switch(optim_opts$pkg, DEoptimR = optim_solve_deoptimr(x = x, Z = Z, 
        loss = loss, loss_deriv = loss_deriv, W = W, optim_opts = optim_opts, maxiter = maxiter, 
        tol = tol, p0 = p0, verbose = verbose), nloptr = optim_solve_nloptr(x = x, 
        Z = Z, loss = loss, loss_deriv = loss_deriv, W = W, optim_opts = optim_opts, 
        maxiter = maxiter, tol = tol, p0 = p0, verbose = verbose))
    
    return(list(phat = optimize$solution, opt = optimize))
}

optim_solve_deoptimr <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts = "DEOptimR", 
    opts = NULL, maxiter = 1000, tol = 1e-10, p0 = NULL, verbose = TRUE) {
    
    out <- tryCatch({
        list(opt_out = DEoptimR::JDEoptim(lower = rep(0, nrow(Z)), upper = rep(1, 
            nrow(Z)), fn = loss, trace = TRUE, triter = maxiter/10, maxiter = maxiter, 
            add_to_init_pop = cbind(diag(1, Kall), rep(1/Kall, Kall)), tol = tol, 
            fnscale = fs), err = NULL)
    }, error = function(e) {
        list(opt_out = NULL, err = e)
    })
    out$solution <- out$opt_out$par
    return(out)
}

optim_solve_nloptr <- function(x, Z, loss, loss_deriv, W = NULL, optim_opts = "DEOptimR", 
    opts = NULL, maxiter = 1000, tol = 1e-10, p0 = NULL, verbose = TRUE) {
    
    algo <- optim_opts$algo
    opt_flags <- optim_opts$fn_flags
    f_deriv <- NULL
    g_ineq <- NULL
    g_ineq_deriv <- NULL
    g_eq <- NULL
    g_eq_deriv <- NULL
    if ("f_deriv" %in% opt_flags) {
        f_deriv <- loss_deriv
    }
    if ("g_ineq" %in% opt_flags) {
        g_ineq <- constr
    }
    if ("g_ineq_deriv" %in% opt_flags) {
        g_ineq_deriv <- constr_deriv
    }
    if ("g_eq" %in% opt_flags) {
        g_eq <- constr
    }
    if ("g_eq_deriv" %in% opt_flags) {
        g_eq_deriv <- constr_deriv
    }
    
    fns <- list(f_deriv, g_ineq, g_ineq_deriv, g_eq, g_eq_deriv)
    names(fns) <- c("f_deriv", "g_ineq", "g_ineq_deriv", "g_eq", "g_eq_deriv")
    names(fns)[!sapply(fns, is.null)]
    
    out <- tryCatch({
        local_opts <- list(algorithm = "NLOPT_LN_COBYLA", xtol_rel = 1e-07)
        list(opt_out = nloptr::nloptr(x0 = p0, eval_f = loss, eval_grad_f = f_deriv, 
            eval_g_ineq = g_ineq, eval_jac_g_ineq = g_ineq_deriv, eval_g_eq = g_eq, 
            eval_jac_g_eq = g_eq_deriv, lb = rep(0, Kall), ub = rep(1, Kall), opts = list(algorithm = algo, 
                xtol_rel = tol, maxeval = maxiter, print_level = 0, local_opts = local_opts)), 
            err = NULL)
    }, error = function(e) {
        list(opt_out = NULL, err = e)
    })
    out$solution <- out$opt_out$solution
    return(out)
}


opts
phats_all
corresp_options
optim_opts
optim_opts = list(pkg = "nloptr",algo="NLOPT_LN_COBYLA",constraints="box")
optim_opts
corresp_options
devtools::load_all()
corresp_options
dtangle:::options_grid
head(dtangle:::options_grid)
options_grid = dtangle:::options_grid
class(corresp_options)
corresp_options
opt_flags
opt_flags
options_grid
optim_opts
corresp_options
algo
algo
corresp_options
corresp_options
corresp_options
corresp_options
optim_opts
optim_opts$algo <- NULL
optim_opts
corresp_options
opt_flags
opt_flags
opt_flags
opt_flags
opt_flags
opt_flags
optim_opts
optim_opts$constraints="eq"
corresp_options
opt_flags
optim_opts$constraints="box"
corresp_options
opt_flags
f_deriv
opt_flags
"a"%in%opt_flags
options_grid$global
View(options_grid)
View(options_grid)
optim_opts = list(pkg = "nloptr",algo="NLOPT_GN_ORIG_DIRECT")
algo
dim(Y)
W
hist(W)
rank
apply(Z,2,sd)
rank(apply(Z,2,sd))
rank(apply(Z,2,sd))/ncol(Z)
sort(rank(apply(Z,2,sd))/ncol(Z))
head(sort(rank(apply(Z,2,sd))/ncol(Z)))
W
hist(W)
W
sed.seed(NULL)
set.seed(NULL)
runif(5)
set.seed(NULL)
runif(5)
set.seed(NULL)
runif(5)
set.seed(1123)
runif(5)
set.seed(1123)
runif(5)
set.seed(1123)
runif(5)
set.seed(NULL)
runif(5)
L
digest::digest(list(p0,x,Z,W))
quit()
n
